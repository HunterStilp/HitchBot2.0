/**
 *  @filename   :   epd3in7.c
 *  @brief      :   Implements for e-paper library
 *  @author     :   Waveshare
 */

#include <stdlib.h>
#include "epd3in7.h"
//#include "imagedata.h" IRRELEVENT? I HOPE
#include "epdif.h"
#include <avr/io.h>
#include <util/delay.h>

#include <avr/pgmspace.h>


static const UBYTE lut_4Gray_GC[] =
{
	0x2A,0x06,0x15,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//1
	0x28,0x06,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//2
	0x20,0x06,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//3
	0x14,0x06,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//4
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//5
	0x00,0x02,0x02,0x0A,0x00,0x00,0x00,0x08,0x08,0x02,//6
	0x00,0x02,0x02,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,//7
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//8
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//9
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//10
	0x22,0x22,0x22,0x22,0x22
};


static const UBYTE lut_1Gray_GC[] =
{
	0x2A,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//1
	0x05,0x2A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//2
	0x2A,0x15,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//3
	0x05,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//4
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//5
	0x00,0x02,0x03,0x0A,0x00,0x02,0x06,0x0A,0x05,0x00,//6
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//7
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//8
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//9
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//10
	0x22,0x22,0x22,0x22,0x22
};

static const UBYTE lut_1Gray_DU[] =
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//1
	0x01,0x2A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0A,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//3
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//5
	0x00,0x00,0x05,0x05,0x00,0x05,0x03,0x05,0x05,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//7
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//9
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x22,0x22,0x22,0x22,0x22
};

static const UBYTE lut_1Gray_A2[] =
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //1
	0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //2
	0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //3
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //4
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //5
	0x00,0x00,0x03,0x05,0x00,0x00,0x00,0x00,0x00,0x00, //6
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //7
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //8
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //9
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //10
	0x22,0x22,0x22,0x22,0x22
};

int epd_init(void) {
    if (epd_if_init() != 0) {
	    return -1;
    }
	
	
	epd_reset();

    epd_send_command(0x12);
    _delay_ms(300);

    epd_send_command(0x46);
    epd_send_data(0xF7);
    epd_wait_until_idle();
    epd_send_command(0x47);
    epd_send_data(0xF7);
    epd_wait_until_idle();

    epd_send_command(0x01); // setting gaet number
    epd_send_data(0xDF);
    epd_send_data(0x01);
    epd_send_data(0x00);

    epd_send_command(0x03); // set gate voltage
    epd_send_data(0x00);

    epd_send_command(0x04); // set source voltage
    epd_send_data(0x41);
    epd_send_data(0xA8);
    epd_send_data(0x32);

    epd_send_command(0x11); // set data entry sequence
    epd_send_data(0x03);

    epd_send_command(0x3C); // set border
    epd_send_data(0x00);

    epd_send_command(0x0C); // set booster strength
    epd_send_data(0xAE);
    epd_send_data(0xC7);
    epd_send_data(0xC3);
    epd_send_data(0xC0);
    epd_send_data(0xC0);

    epd_send_command(0x18); // set internal sensor on
    epd_send_data(0x80);

    epd_send_command(0x2C); // set vcom value
    epd_send_data(0x44);

    epd_send_command(0x37); // set display option, these setting turn on previous function
    epd_send_data(0x00);
    epd_send_data(0xff);
    epd_send_data(0xff);
    epd_send_data(0xff);
    epd_send_data(0xff);
    epd_send_data(0x4f);
    epd_send_data(0xff);
    epd_send_data(0xff);
    epd_send_data(0xff);
    epd_send_data(0xff);

    epd_send_command(0x44); // setting X direction start/end position of RAM
    epd_send_data(0x00);
    epd_send_data(0x00);
    epd_send_data(0x17);
    epd_send_data(0x01);

    epd_send_command(0x45); // setting Y direction start/end position of RAM
    epd_send_data(0x00);
    epd_send_data(0x00);
    epd_send_data(0xDF);
    epd_send_data(0x01);

    epd_send_command(0x22); // Display Update Control 2
    epd_send_data(0xCF);
    return 0;
}

void epd_send_command(unsigned char command) {
    epd_digital_write(DC_PIN, false);
	epd_spi_transfer(command);
}

void epd_send_data(unsigned char data) {
    epd_digital_write(DC_PIN, true);
	epd_spi_transfer(data);
}

void epd_wait_until_idle(void) {
    UBYTE busy;
	do {
		busy = epd_digital_read(BUSY_PIN);
	} while(busy);
	_delay_ms(20);//prev200
}

void epd_reset(void) {
    epd_digital_write(RST_PIN, true);
    _delay_ms(20);
	epd_digital_write(RST_PIN, false);
	_delay_ms(2);
	epd_digital_write(RST_PIN, true);
	_delay_ms(20);
}

void epd_display_frame(const UBYTE *Image, bool isBase) {
    UWORD i;
    unsigned long IMAGE_COUNTER = EPD_WIDTH / 8 * EPD_HEIGHT;

    epd_send_command(0x4E);
    epd_send_data(0x00);
    epd_send_data(0x00);
    epd_send_command(0x4F);
    epd_send_data(0x00);
    epd_send_data(0x00);
	
	epd_send_command(0x24);
	for (i = 0; i < IMAGE_COUNTER; i++) {
		epd_send_data(pgm_read_byte(&Image[i]));
	}
	if(isBase) {
		epd_send_command(0x26);
		for (i = 0; i < IMAGE_COUNTER; i++) {
			epd_send_data(pgm_read_byte(&Image[i]));
		}
	}
	
	epd_load_lut(1);
	epd_send_command(0x20);
	epd_wait_until_idle();
}

void epd_display_frame_partial(const UBYTE *Image, UWORD Xstart, UWORD Ystart, UWORD iwidth, UWORD iheight) {
    UWORD i;
	UWORD j;
	
	epd_send_command(0x4E);
	epd_send_data(0x00);
	epd_send_data(0x00);
	epd_send_command(0x4F);
	epd_send_data(0x00);
	epd_send_data(0x00);
	
	epd_send_command(0x24);
	for(i=0; i<EPD_WIDTH; i++) {
		for(j=0; j<EPD_HEIGHT/8; j++) {
			if(i>=Ystart && i<Ystart+iheight && j>=Xstart/8 && j<(Xstart+iwidth)/8)
				epd_send_data(Image[(j-Xstart/8) + (i-Ystart)*iwidth/8]);
			else
				epd_send_data(0xff);
		}
	}
	
	epd_load_lut(0);
	epd_send_command(0x20);
	epd_wait_until_idle();
}

void epd_display_frame_part(const UBYTE *Image, UWORD Xstart, UWORD Ystart, UWORD Xend, UWORD Yend, bool isGC) {
	UWORD i, Width;
	Width = (Xend-Xstart)%8 == 0 ? (Xend-Xstart)/8 : (Xend-Xstart)/8+1;
	UWORD IMAGE_COUNTER = Width * (Yend-Ystart);

	Xend -= 1;
	Yend -= 1;

	epd_send_command(0x44);
	epd_send_data(Xstart & 0xff);
	epd_send_data((Xstart>>8) & 0x03);
	epd_send_data(Xend & 0xff);
	epd_send_data((Xend>>8) & 0x03);
	epd_send_command(0x45);
	epd_send_data(Ystart & 0xff);
	epd_send_data((Ystart>>8) & 0x03);
	epd_send_data(Yend & 0xff);
	epd_send_data((Yend>>8) & 0x03);

	epd_send_command(0x4E); // SET_RAM_X_ADDRESS_COUNTER
	epd_send_data(Xstart & 0xFF);

	epd_send_command(0x4F); // SET_RAM_Y_ADDRESS_COUNTER
	epd_send_data(Ystart & 0xFF);
	epd_send_data((Ystart >> 8) & 0xFF);
	
	epd_send_command(0x24);
	
	
	for (i = 0; i < IMAGE_COUNTER; i++)
	{
		epd_send_data(Image[i]);
	}
	if(isGC)
		epd_load_lut(1);
	else
		epd_load_lut(0);
}

// void epd_set_window(UWORD Xstart, UWORD Ystart, UWORD Xend, UWORD Yend) {
//     
// }
//I BELIEVE THIS IS OBSOLETE


// void epd_set_cursor(Epd *epd, UWORD Xstart, UWORD Ystart) {
//     // (content unchanged, replace "this->" with "epd->")
// }
//ALSO BELIEVE THIS DOESNT EXIST

void epd_turn_on_display(void) {
    epd_send_command(0x20);
    epd_wait_until_idle();
}

void epd_sleep(void) {
    epd_send_command(0X10);   //deep sleep
    epd_send_data(0x03);
}

void epd_clear(UBYTE mode) {
	UWORD i;
	unsigned long IMAGE_COUNTER = EPD_WIDTH / 8 * EPD_HEIGHT;

	epd_send_command(0x4E);
	epd_send_data(0x00);
	epd_send_data(0x00);
	epd_send_command(0x4F);
	epd_send_data(0x00);
	epd_send_data(0x00);

	epd_send_command(0x24);
	for (i = 0; i < IMAGE_COUNTER; i++)
	{
		epd_send_data(0xff);
	}
	if(mode)
		epd_load_lut(1);
	else
		epd_load_lut(0);
	epd_send_command(0x20);
	epd_wait_until_idle();
}

void epd_load_lut(UBYTE mode) {
    UWORD i;
    epd_send_command(0x32);
    for (i = 0; i < 105; i++) {
	    if(mode == 1)
			epd_send_data(lut_1Gray_GC[i]);
	    else if(mode == 0)
			epd_send_data(lut_1Gray_A2[i]);
    }
	
}